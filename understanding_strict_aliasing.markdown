# Осмысление правил перекрытия объектов в памяти в языках C/C++
## или - Почему этот #$@##@^% компилятор не даёт мне делать то что нужно!
#### автор Патрик Хоган (Patrick Horgan)
#### [оригинал](http://dbp-consulting.com/tutorials/StrictAliasing.html)

#### Предисловие переводчика

В статье идёт речь про явление `strict aliasing`. В gcc оно переводится как "правила перекрытия объектов в памяти", поэтому в данном переводе будет использоваться именно этот термин.

##Итак, в чём проблема?

Существует множество заблуждений о правилах перекрытия объектов в памяти. Главный источник заблуждений в том, что существует две разных аудитории, говорящих о перекрытии объектов - разработчики, использующие компиляторы, и авторы компиляторов. В этой статье я собираюсь попробовать разложить всё по полочкам для Вас. Вещи, о которых я собираюсь рассказать, основаны на правилах перекрытия в C89/90 (**6.3**), C98/99 (**6.5/7**) а также в C++98 (**3.10/15**), и C++0x (**3.10/10**). Для того, чтобы найти правила перекрытия в любой текущей версии C или C++ стандарта, ищите по словам "may not be aliased", которые Вы найдёте в сноске, на которую ссылается секция, описывающая допустимые формы перекрытия. Для справки о том, что имели ввиду создатели спецификаций, см. [C89 Rationale](http://www.cs.technion.ac.il/users/yechiel/CS/C++draft/rationale.pdf) Section 3.3 Expressions, где они рассказывают, как и почему были выведены правила перекрытия.

Разработчики начинают интересоваться перекрытием объектов, когда компилятор выдаёт им предупреждение о приведении типов и правилах перекрытия объектов в памяти, и они пытаются понять, что же значат эти предупреждения. Они гуглят эти сообщения, находят ссылки на секцию перекрытия в одной из C или C++ спецификаций и думают: "Да, это то что я пытаюсь сделать, перекрытие". Потом они изучают секцию соответствующей спецификации так, будто учат магические руны, и пытаются угадать правила, которые позволят им делать вещи, которые они пытаются сделать. Они думают, что правила перекрытия написаны, чтобы объяснить им, как следует делать приведение типов. Нет большего заблуждения, чем это.

Создатели компиляторов знают, для чего нужны правила перекрытия. Они написаны, чтобы позволить создателям компилятора знать, когда они могут безопасно полагать, что изменение, сделанное для одной переменной, не повлияет на значение другой переменной, и наоборот, когда им следует предполагать, что две переменные *могут* по факту указывать на один и тот же участок памяти.

Итак, эта статья разделена на две части. Во-первых, я расскажу, что такое правила перекрытия (strict aliasing), и почему они существуют, а затем я расскажу, как делать необходимые разработчикам вещи способами, не приводящими к конфликтам с этими правилами.

##Часть первая. Что именно есть перекрытие?

Перекрытие (aliasing) - это когда одно или более lvalue указывает на тот же участок памяти (когда Вы слышите "lvalue", думайте об объектах (переменные), которые могут быть на левой стороне присваиваний)

Как пример:

	int anint;
	int *intptr =&anint;

Если Вы меняете значение `*intptr`, то значение, на которое указывает `anint` тоже меняется, потому что `*intptr` перекрывает `anint`. Это просто другое имя той же вещи.

Другой пример:

	int anint;
	void foo(int &i1, int &i2);
	foo(anint,anint);

Внутри тела функции, после того как мы использовали `anint` в качестве обоих аргументов, есть две ссылки, `i1` и `i2` перекрывающие друг друга, т.е. ссылки на одну область памяти, когда функция вызывается таким образом.

## В чём проблема?

Проверим следующий код:

	int anint;
	void foo(double *dblptr)
	{
		anint=1;
		*dblptr=3.14159;
		bar(anint);
	}

Если посмотреть на пример, кажется безопасным предполагать, что аргумент `bar()` - константа, равная 1. В старые добрые времена создатели компиляторов должны были исходить из худшего предположения о перекрывающем присваивании, чтобы поддерживать огромное количество унаследованного кода с дикого запада. Они не могли сказать, что было бы безопасно предполагать что аргумент `bar` был равен 1. Они должны были вставлять код для повторной выгрузки значения `anint` для вызова функции, потому что промежуточное присваивание через `dblptr` могло изменить значение `anint`, если бы `dblptr` указывал на неё. *Возможно*, что вызов `foo` выглядел бы как `foo((double *) &anint)`.

Именно эту проблему призваны решить правила перекрытия. Перед создателями оптимизирующих компиляторов был низко висящий плод, и они хотели заставить программистов следовать правилам перекрытия объектов в памяти, чтобы его сорвать. Перекрытие и проблемы, к которым оно приводит, существуют столько, сколько существует язык C. Разница в последнее время заключается в том, что создатели компиляторов строго относятся к правилам и применяют их, когда включены оптимизации. В свои стандарты C и C++ они включают списки объектов, которые имеют право перекрываться, (см. следующую секцию), а в остальных случаях создателям компиляторов разрешено предполагать отсутствие пересечений между lvalues. Для того, чего нет в списке, предполагается отсутствие пересечений, и создатели компиляторов могут свободно проводить оптимизации, которые опираются на эти предположения. Для того, что есть в списке, перекрытие возможно и создатели компиляторов должны предполагать, что оно выполняется. Когда создатели компиляторов работают по этим
спискам и предполагают, что Ваш код следует правилам, это называется "правила перекрытия объектов в памяти" (strict-aliasing). Под правилами перекрытия, создатель компилятора может оптимизировать функцию `foo`, приведённую выше, потому что несовместимые типы, `double` и `int` не могут перекрываться. Это значит, что если Вы делаете вызов `foo` как `foo((double *)&anint)`, что-то очень скоро пойдёт не так, но Вы получите по заслугам.

##Итак, что могут перекрытия?

Из C9899:201x *6.5 Expressions*:

>- Доступ к объекту может осуществляться только через lvalue выражение, которое имеет один из следующих типов:

>- тип, совместимый с фактическим типом объекта;

>- версия типа с квалификатором, при условии, что фактический тип совместим с типом объекта;

>- тип, являющийся signed или unsigned типом, по отношению к фактическому типу объекта;

>- тип, являющийся signed или unsigned типом, по отношению к фактическому типу объекта с квалификатором;

>- агрегатный тип или union, который включает одиг из вышеупомянутых типов среди своих членов (включая рекурсивно члены агрегатов или содержащиеся в union);

>- символьный (char) тип;

Подытожим вышесказанное:

* Объекты совместимых типов, или различающихся только дополнением любой комбинации `signed`, `unsigned`, `volatile`. В большинстве случаев совместимый тип означает тот же самый тип. Если вам нужно больше деталей, можете почитать спецификацию. (Пример: Если у Вас есть указатель на `long` и указатель на `const unsigned long`, они могут указывать на один и тот же объект.)

* Агрегатные типы (`struct` или `class`) или `union` могут перекрываться типами, содержащимися внутри них. (Пример: Если функция принимает указатель на `int` и указатель на `struct` или `union`, содержащий `int` или, возможно, содержащий другой `struct` или `union`, содержащий `int` или содержащий... до бесконечности, то возможно, `int *` указывает на `int`, содержащийся внутри `struct` или `union`, на который указывает другой указатель.)

* Символьный тип. Типам `char*`, `signed char*`, или `unsigned char*` спецификация разрешает в особом порядке указывать на всё что угодно. Это значит, что они могут указывать на любую область памяти.

* Только для C++, типы базовых классов, возможно, с *CV* (`const` и/или `volatile`) квалификаторами, могут перекрывыться дочерними типами. (Например: если класс `dog` является наследником класса `animal`, указатели и ссылки на класс `dog` и класс `animal` могут перекрываться.)

Конечно, ссылки обладают всеми теми же свойствами, что и указатели, и ссылки и указатели могут перекрываться. Для любого lvalue следует предполагать возможность перекрытия с другим lvalue, если правила говорят, что они могут перекрываться. Правила перекрытия для ссылок на значения действуют точно так же, как для указателей на значения. Кроме того, любая комбинация указателей и ссылок может перекрываться, и Вам следует опираться на правила перекрытия, чтобы понимать, что может произойти.

## Часть вторая. Как сделать что-то, что не нравится компилятору.

Следующая программа меняет местами две половинки 32-х битного целого. Она представляет пример типичного кода для обмена информацией, между little-endian и big-endian машинами. Он также выдаёт 6 предупреждений о нарушении правил перекрытия объектов в памяти. Многие пропустят их. Корректный вывод программы:

	00000020 00200000

но при включённой оптимизации он становится:

	00000020 00000020

Это ТО, что предупреждение пыталось сказать Вам: оптимизатор собирается сделать вещи, которые Вам не понравятся. Не думайте что это означает, что оптимизатор испортил Ваш код. Он уже испорчен. Оптимизатор просто указал Вам на это.

## Неправильная версия:

	uint32_t
	swaphalves(uint32_t a)
	{
		uint32_t acopy=a;
		uint16_t *ptr=(uint16_t*)&acopy;	// нельзя использовать static_cast<>, неправильно.
											// Вам должно выводиться предупреждение об этом.
		uint16_t tmp=ptr[0];
		ptr[0]=ptr[1];
		ptr[1]=tmp;
		return acopy;
	}

	int main()
	{
		uint32_t a;
		a=32;
		cout << hex << setfill('0') << setw(8) << a << endl;
		a=swaphalves(a);
		cout << setw(8) << a << endl;
	}

Итак, что же здесь неправильно? Хотя `uint16_t` и `uint32_t` по правилам не могут перекрываться, это игнорируется при работе с `acopy`. Видно, что внутри `swaphalvesfunction` ничего не происходит с переменной `acopy`, функция просто возвращает начальное значение `a`. Вот аннотированный x86 ассемблер, генерируемый gcc 4.4.1 для `swaphalvesfunction`, давайте посмотрим что пошло не так:

	_Z10swaphalvesj:
		pushl %ebp
		movl %esp, %ebp
		subl $16, %esp
		movl 8(%ebp), %eax 		# положим a в %eax
		movl %eax, -8(%ebp) 	# и запишем его в acopy
		leal -8(%ebp), %eax 	# теперь получим eax указывающий на acopy (ptr=&acopy)
		movl %eax, -12(%ebp) 	# сохраним этот ptr в -12(%ebp)
		movl -12(%ebp), %eax 	# положим этот ptr обратно в %eax
		movzwl (%eax), %eax 	# положим 16 бит из ptr[0] в eax
		movw %ax, -2(%ebp) 		# запишем 16 бит в tmp
		movl -12(%ebp), %eax 	# положим ptr обратно в eax
		addl $2, %eax 			# увеличим на 2 чтобы добраться до ptr[1]
		movzwl (%eax), %edx 	# запишем эти 16 бит в %edx
		movl -12(%ebp), %eax 	# запишем ptr в eax
		movw %dx, (%eax) 		# сохраним 16 бит в ptr[1]
		movl -12(%ebp), %eax 	# запишем ptr ещё раз
		leal 2(%eax), %edx 		# запишем адрес ptr[1] в edx
		movzwl -2(%ebp), %eax 	# запишем tmp в eax
		movw %ax, (%edx) 		# сохраним в ptr[1]
		movl -8(%ebp), %eax 	# забудем всё это и вернём изначальное a.
		leave
		ret

Жутковато, не правда ли? Конечно, если Вы используете gcc, Вы могли бы использовать `-fno-strict-aliasing` чтобы получить то что ожидали, но сгенерированный код не будет так хорош и Вы просто избавитесь от симптома вместо решения проблемы. Лучший способ добиться того же без получения предупреждений или некорректного вывода - это определить `swaphalves` следующим образом. Заметьте, что этот способ поддерживается в стандартах C99 и новее, в сноске к *6.5.2.3 Structure and union members*:

> 85\. Если член использовавшийся для доступа к содержимому объекта `union` не является таким же как последний член, использовавшийся для записи значения в объект, соответствующая часть представления объекта начинает интерпретироваться как новый тип, что описано в 6.2.6 (процесс иногда называется "приведение типов" (type-punning)). Это может быть обманным представлением.

но польза от этого в C++ может различаться. Все C++ компиляторы, о которых мне известно, поддерживают этот способ, но спецификация C++ этого не разрешает, так что опасно рассчитывать на него. Сразу после этого обсуждения я предложу другое возможное (а может быть и нет) решение с использованием `memcpy`, немного менее эффективное, и поддерживаемое как C так и C++:

## Версия с `union`. Работает для C но нет гарантий портируемости в C++.

	uint32_t
	swaphalves(uint32_t a)
	{
		typedef union
		{
			uint32_t as32bit;
			uint16_t as16bit[2];
		} swapem;

		swapem s={a};
		uint16_t tmp;
		tmp=s.as16bit[0];
		s.as16bit[0]=s.as16bit[1];
		s.as16bit[1]=tmp;
		return s.as32bit;
	}

Компилятор C++  знает, что члены `union` занимают одну память, и это помогает компилятору генерировать ГОРАЗДО лучший код:

	_Z10swaphalvesj:
		pushl %ebp 			# сохраним изначальное значение ebp
		movl %esp, %ebp 	# пусть ebp указывает на фрейм стека
		movl 8(%ebp), %eax 	# запишем a в eax
		popl %ebp 			# запишем обратно оригинальное значение ebp
		roll $16, %eax 		#поменяем местами две половинки и вернём их
		ret

Итак, Вы можете сделать это неправильно через странные приведения и получите некорректный код, либо выключите `strict-aliasing` и получите неэффективный код, или Вы сделаете это правильно и получите эффективный код.

Вы можете также сделать то же самое, используя `memcpy` с `char *` чтобы поменять местами данные, и это скорей всего будет эффективно. *Постойте*, спросите Вы меня, как такое может быть? Будет как минимум два вызова функции `memcpy`, добавленные в код! Что ж, gcc и другие современные компиляторы имеют умные оптимизаторы и во многих случаях (включая этот) соптимизируют вызов `memcpy`. Это сделает метод более портируемым и таким же эффективным как остальные. Вот как это будет выглядеть:

## Версия с `memcpy`, совместимая со стандартами C и C++ и в тоже время эффективная

	uint32_t
	swaphalves(uint32_t a)
	{
		uint16_t as16bit[2],tmp;
		memcpy(as16bit, &a, sizeof(a));
		tmp = as16bit[0];
		as16bit[0] = as16bit[1];
		as16bit[1] = tmp;
		memcpy(&a, as16bit, sizeof(a));
		return a;
	}

Для вышеприведённого кода, компилятор C сгенерирует код, близкий к предыдущему решению, но с дополнительными двумя вызовами `memcpy` (возможно соптимизированными). gcc генерирует код, *идентичный* предыдущему решению. Вы можете придумать другие варианты, которые заменят вызовы `memcpy` на локальные чтение и запись через указатель на `char`.

Подобные приёмы пришли из кода, работающего с сетью, где Вы не можете знать, какого типа пакет Вам пришёл, пока не проверите его. `unions` и/или `memcpy` Ваши друзья и в этом случае.

## Ключевое слово `restrict`

В C99, но не во всех C++ при помощи ключевого слова `restrict` Вы можете пообещать компилятору, что указатель на что-то не перекрывается. В ситуации, когда компилятор должен ожидать, что объекты могут перекрываться, Вы можете сказать компилятору, что обещаете, что этого не будет. Как здесь:

	void foo(int * restrict i1, int * restrict i2);

Вы говорите, что *обещаете* компилятору, что `i1` и `i2` никогда не укажут на один участок памяти. Вы должны хорошо знать реализацию `foo` и использовать только код, который держит данное обещание, что объекты, проходящие через `i1` и `i2` никогда не перекрываются. Компилятор верит Вам и может лучше выполнить работу по оптимизации. Если же Вы нарушите обещание, то Ваша полезность может измениться (и говоря это, я подразумеваю, что Вам почти наверняка захочется плакать). Этот функционал отсутствует в C++.

Если у Вас есть комментарии, правки, предложения по улучшению или примеры - не стесняйтесь, пишите мне.

Спасибо,

Патрик Хоган (Patrick Horgan)

patrick at dbp-consulting dot com

## Комплименты и благодарности

Особую благодарность хочется выразить людям, участвовавшим в обсуждении этого документа в рассылках boost-users и gcc-help. В особенности я хотел бы поблагодарить Вацлава Хайсмана (Václav Haisman), Томаса Хеллера (Thomas Heller), которые писали версию с `memcpy`, размещённую здесь, и выяснили, что она генерирует точно такой же ассемблер, и Андрю Хали (Andrew Haley), который выяснил, что наиболее портабельный способ - через определение `union` и также выяснил, что gcc избавится от вызова `memcpy`.

Дополнительно я хотел бы поблагодарить Гйеба Джонса (Gabe Jones) за отлов тараканов в голове :)
