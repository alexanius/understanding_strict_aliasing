# Осмысление правил перекрытия объектов в памяти в языках C/C++
##или - Почему этот #$@##@^% компилятор не даёт мне делать то что нужно!
####автор Патрик Хоган (Patrick Horgan)
####[оригинал](http://dbp-consulting.com/tutorials/StrictAliasing.html)

##Итак, в чём проблема?

Существует множество заблуждений о правилах перекрытия объектов в памяти. Главный источник заблуждений в том, что существует две разных аудитории, говорящих о strict aliasing (*) - разработчики, использующие компиляторы и авторы компиляторов. В этой статье я собираюсь попробовать разложить всё по полочкам для вас. Вещи, о которых я собираюсь рассказать основаны на правилах перекрытия в C89/90 (6.3), C98/99 (6.5/7) а также в C++98 (3.10/15), и C++0x (3.10/10). Для того, чтобы найти правила aliasing'а в любой текущей версии C или C++ стандарта, ищите по словам "may not be aliased", которые Вы найдёте в сноске, на которую ссылается секция, описывающая допустимые формы перекрытия. Для справки о том, что имели ввиду создатели спецификаций, см. [C89 Rationale](http://www.cs.technion.ac.il/users/yechiel/CS/C++draft/rationale.pdf) Section 3.3 Expressions, где они рассказывают почему и как были выведены правила перекрытия.

Разработчики начинают интересоваться aliasing'ом когда компилятор выдаёт им предупреждение о приведении типов и правилах перекрытия объектов в памяти, и они пытаются понять что же значат эти предупреждения. Они гуглят эти сообщения, они находят ссылки к секции aliasing'а в одной из C или C++ спецификаций и думают: "Да, это то что я пытаюсь сделать, перекрытие". Потом они изучают секцию соответствующей спецификации так, будто они учат магические руны и пытаются угадать правила, которые позволят делать им вещи, которые они пытаются сделать. Они думают, что правила перекрытия написаны чтобы объяснить им как следует делать приведение типов. Нельзя быть более далёким от истины.

Создатели компиляторов знают для чего нужны правила strict aliasing. Они написаны чтобы позволить создателям компилятора знать, когда они могут безопасно полагать, что изменение, сделанное для одной переменной не повлияет на значение другой переменной и наоборот, конца им следует предполагать, что две переменные могут по факту указывать на один и тот же участок памяти.

Итак, эта статья разделена на две части. Во-первых я рассказу что такое strict aliasing и почему он существует, а затем я расскажу как делать вещи, необходимые разработчикам способами, не приводящими к конфликтам с этими правилами.

##Часть первая. Что именно есть перекрытие?

Перекрытие (aliasing) - это когда одно или более lvalue указывает на тот же участок памяти (когда Вы слышите "lvalue", думайте о вещах (переменные), которые могут быть на левой стороне присваиваний)

Как пример:

	int anint;
	int *intptr =&anint;

Если Вы меняет значение `*intptr`, значение, на которое указывает `anint` тоже меняется, потому что `*intptr` перекрывает (aliases) `anint`. Это просто другое имя той же вещи.

Другой пример:

	int anint;
	void foo(int &i1, int &i2);
	foo(anint,anint);

Внутри тела функции, после того как мы использовали `anint` в качестве обоих аргументов, есть две ссылки, `i1` и `i2` alias'а т.е. ссылки на одну область памяти когда функция вызывается таким образом.

В чём проблема?

Проверим следующий код:

	int anint;
	void foo(double *dblptr)
	{
	anint=1;
	*dblptr=3.14159;
	bar(anint);
	}

Если посмотреть на пример, кажется безопасным предполагать что аргумент `bar()` - константа, равная 1. В старые добрые времена создатели компиляторов должны были исходить из худшего предположения о перекрывающем присваивании чтобы поддерживать огромное количество унаследованного кода с дикого запада. Они не могли сказать что было бы безопасно предполагать что аргумент bar был 1. Они должны были вставлять код для повторной выгрузки значения `anint` для вызова функции потому что промежуточное присваивание через `dblptr` могло изменить значение `anint`, если бы `dblptr` указывал на неё. Возможно, что вызов выглядел как `foo((double *) &anint)`.

Именно эту проблему призван решить strict aliasing. Перед создателями оптимизирующих компиляторов был низко весящий фрукт, и они хотели заставить программистов следовать правилам перекрытия объектов в памяти чтобы его сорвать. Перекрытие и проблемы к которым оно приводит существуют столько, сколько существует язык C. Разница в последнее время заключается в том, что создатели компиляторов строго относятся к правилам и применяют их когда включены оптимизации. В своих стандартах C и C++ они включают списки вещей которые имеют право перекрываться, (с.м. следующую секцию), и во всех других случаях, создателям компиляторов разрешено предполагать отсутствие пересечений между lvalues. Для чего-то, чего нет в списке, предполагается отсутствие пересечений, и создатели компиляторов могут свободно проводить оптимизации, которые опираются на эти предположения. Для того что есть в списке, перекрытие возможно и создатели компиляторов должны предполагать что оно выполняется. Когда создатели компиляторов работают по этим 
спискам и предполагают, что Ваш код следует правилам, это называется "правила перекрытия объектов в памяти" (strict-aliasing). Под правилами перекрытия, создатель компилятора может оптимизировать функцию `foo`, приведённую выше, потому что несовместимые типы, `double` и `int` не могут перекрываться. Это значит, что если Вы делаете вызов `foo` как `foo((double *)&anint)`, что-то очень скоро пойдёт не так, но Вы получите то что заслужили.

##Итак, что могут перекрытия?

Из C9899:201x *6.5 Expressions*:

- Доступ к объекту может осуществляться только через lvalue выражение, которое имеет один из следующих типов:

- тип, совместимый с фактическим типом объекта

- версия типа с квалификатором, при условии, что фактический тип совместим с типом объекта

- тип, являющийся знаковым или беззнаковым типом, по отношению к фактическому типу объекта

- тип, являющийся знаковым или беззнаковым типом, по отношению к фактическому типу объекта с квалификатором

- агрегатный тип или union, который включает одиг из вышеупомянутых типов среди своих членов (включая рекурсивно члены агрегатов или содержащиеся в union)

- символьный (char) тип

Подытожим вышесказанное:

* Вещи совместимых типов, или различающихся только дополнением любой комбинации `signed`, `unsigned`, `volatile`. В большинстве случаев совместимый тип означает тот же самый тип. Если вам нужно больше деталей, можете почитать спецификацию. (Пример: Если у Вас есть указатель на `long` и указатель на `const unsigned long`, они могут указывать на одну и туже вещь.)

* Аггрегантые типы (`struct` или `class`) или `union` могут перекрываться типами, содержащимися внутри них. (Пример: Если функция принимает указатель на `int` и указатель на `struct` или `union`, содержащий `int` или, возможно, содержащий другой `struct` или `union`, содержащий `int` или содержащий... до бесконечности, то возможно, `int *` указывает на `int`, содержащийся внутри `struct` или `union`, на который указывает другой указатель.)

* Символьный тип. Типам `char*`, `signed char*`, или `unsigned char*` спецификация разрешает в особом порядке указывать на всё что угодно. Это значит, что они могут указывать на любую область памяти.

* Только для C++, типы базовых классов, возможно, с *CV* (`const` и/или `volatile`) квалификаторами, могут перекывыться дочерними типами. (Например: если класс `dog` является наследником класса `animal`, указатели и ссылки на класс `dog` и класс `animal` могут перекрываться.)

Конечно, ссылки обладают всеми теми же свойствами, что и указатели, и ссылки и указатели могут перекрываться. Для любого lvalue следует предполагать возможность перекрытия с другим lvalue, если правила говорят, что они могут перекрываться. Правила перекрытия для ссылок на значения действуют точно также, как для указателей на значения. Кроме того, любая комбинация указателей и ссылок может перекрываться, и Вам следует опираться на правила перекрытия чтобы понимать что может произойти.

(*) Примечание: в gcc термин `strict aliasing' переводится как "правила
перекрытия объектов в памяти".
Т.к. это довольно длинная формулировка, в статье иногда будет использоваться
оригинальный термин.
