# Осмысление правил перекрытия объектов в памяти в языках C/C++
## или - Почему этот #$@##@^% компилятор не даёт мне делать то что нужно!
#### автор Патрик Хоган (Patrick Horgan)
#### [оригинал](http://dbp-consulting.com/tutorials/StrictAliasing.html)

#### Предисловие переводчика

В статье идёт речь про явление `strict aliasing`. В gcc оно переводится как "правила перекрытия объектов в памяти", поэтому ы этом переводе будет использоваться именно этот термин.

##Итак, в чём проблема?

Существует множество заблуждений о правилах перекрытия объектов в памяти. Главный источник заблуждений в том, что существует две разных аудитории, говорящих о strict aliasing (*) - разработчики, использующие компиляторы и авторы компиляторов. В этой статье я собираюсь попробовать разложить всё по полочкам для вас. Вещи, о которых я собираюсь рассказать основаны на правилах перекрытия в C89/90 (6.3), C98/99 (6.5/7) а также в C++98 (3.10/15), и C++0x (3.10/10). Для того, чтобы найти правила aliasing'а в любой текущей версии C или C++ стандарта, ищите по словам "may not be aliased", которые Вы найдёте в сноске, на которую ссылается секция, описывающая допустимые формы перекрытия. Для справки о том, что имели ввиду создатели спецификаций, см. [C89 Rationale](http://www.cs.technion.ac.il/users/yechiel/CS/C++draft/rationale.pdf) Section 3.3 Expressions, где они рассказывают почему и как были выведены правила перекрытия.

Разработчики начинают интересоваться aliasing'ом когда компилятор выдаёт им предупреждение о приведении типов и правилах перекрытия объектов в памяти, и они пытаются понять что же значат эти предупреждения. Они гуглят эти сообщения, они находят ссылки к секции aliasing'а в одной из C или C++ спецификаций и думают: "Да, это то что я пытаюсь сделать, перекрытие". Потом они изучают секцию соответствующей спецификации так, будто они учат магические руны и пытаются угадать правила, которые позволят делать им вещи, которые они пытаются сделать. Они думают, что правила перекрытия написаны чтобы объяснить им как следует делать приведение типов. Нельзя быть более далёким от истины.

Создатели компиляторов знают для чего нужны правила strict aliasing. Они написаны чтобы позволить создателям компилятора знать, когда они могут безопасно полагать, что изменение, сделанное для одной переменной не повлияет на значение другой переменной и наоборот, конца им следует предполагать, что две переменные могут по факту указывать на один и тот же участок памяти.

Итак, эта статья разделена на две части. Во-первых я рассказу что такое strict aliasing и почему он существует, а затем я расскажу как делать вещи, необходимые разработчикам способами, не приводящими к конфликтам с этими правилами.

##Часть первая. Что именно есть перекрытие?

Перекрытие (aliasing) - это когда одно или более lvalue указывает на тот же участок памяти (когда Вы слышите "lvalue", думайте о вещах (переменные), которые могут быть на левой стороне присваиваний)

Как пример:

	int anint;
	int *intptr =&anint;

Если Вы меняет значение `*intptr`, значение, на которое указывает `anint` тоже меняется, потому что `*intptr` перекрывает (aliases) `anint`. Это просто другое имя той же вещи.

Другой пример:

	int anint;
	void foo(int &i1, int &i2);
	foo(anint,anint);

Внутри тела функции, после того как мы использовали `anint` в качестве обоих аргументов, есть две ссылки, `i1` и `i2` alias'а т.е. ссылки на одну область памяти когда функция вызывается таким образом.

В чём проблема?

Проверим следующий код:

	int anint;
	void foo(double *dblptr)
	{
	anint=1;
	*dblptr=3.14159;
	bar(anint);
	}

Если посмотреть на пример, кажется безопасным предполагать что аргумент `bar()` - константа, равная 1. В старые добрые времена создатели компиляторов должны были исходить из худшего предположения о перекрывающем присваивании чтобы поддерживать огромное количество унаследованного кода с дикого запада. Они не могли сказать что было бы безопасно предполагать что аргумент bar был 1. Они должны были вставлять код для повторной выгрузки значения `anint` для вызова функции потому что промежуточное присваивание через `dblptr` могло изменить значение `anint`, если бы `dblptr` указывал на неё. Возможно, что вызов выглядел как `foo((double *) &anint)`.

Именно эту проблему призван решить strict aliasing. Перед создателями оптимизирующих компиляторов был низко весящий фрукт, и они хотели заставить программистов следовать правилам перекрытия объектов в памяти чтобы его сорвать. Перекрытие и проблемы к которым оно приводит существуют столько, сколько существует язык C. Разница в последнее время заключается в том, что создатели компиляторов строго относятся к правилам и применяют их когда включены оптимизации. В своих стандартах C и C++ они включают списки вещей которые имеют право перекрываться, (с.м. следующую секцию), и во всех других случаях, создателям компиляторов разрешено предполагать отсутствие пересечений между lvalues. Для чего-то, чего нет в списке, предполагается отсутствие пересечений, и создатели компиляторов могут свободно проводить оптимизации, которые опираются на эти предположения. Для того что есть в списке, перекрытие возможно и создатели компиляторов должны предполагать что оно выполняется. Когда создатели компиляторов работают по этим 
спискам и предполагают, что Ваш код следует правилам, это называется "правила перекрытия объектов в памяти" (strict-aliasing). Под правилами перекрытия, создатель компилятора может оптимизировать функцию `foo`, приведённую выше, потому что несовместимые типы, `double` и `int` не могут перекрываться. Это значит, что если Вы делаете вызов `foo` как `foo((double *)&anint)`, что-то очень скоро пойдёт не так, но Вы получите то что заслужили.

##Итак, что могут перекрытия?

Из C9899:201x *6.5 Expressions*:

>- Доступ к объекту может осуществляться только через lvalue выражение, которое имеет один из следующих типов:

>- тип, совместимый с фактическим типом объекта

>- версия типа с квалификатором, при условии, что фактический тип совместим с типом объекта

>- тип, являющийся знаковым или беззнаковым типом, по отношению к фактическому типу объекта

>- тип, являющийся знаковым или беззнаковым типом, по отношению к фактическому типу объекта с квалификатором

>- агрегатный тип или union, который включает одиг из вышеупомянутых типов среди своих членов (включая рекурсивно члены агрегатов или содержащиеся в union)

>- символьный (char) тип

Подытожим вышесказанное:

* Вещи совместимых типов, или различающихся только дополнением любой комбинации `signed`, `unsigned`, `volatile`. В большинстве случаев совместимый тип означает тот же самый тип. Если вам нужно больше деталей, можете почитать спецификацию. (Пример: Если у Вас есть указатель на `long` и указатель на `const unsigned long`, они могут указывать на одну и туже вещь.)

* Аггрегантые типы (`struct` или `class`) или `union` могут перекрываться типами, содержащимися внутри них. (Пример: Если функция принимает указатель на `int` и указатель на `struct` или `union`, содержащий `int` или, возможно, содержащий другой `struct` или `union`, содержащий `int` или содержащий... до бесконечности, то возможно, `int *` указывает на `int`, содержащийся внутри `struct` или `union`, на который указывает другой указатель.)

* Символьный тип. Типам `char*`, `signed char*`, или `unsigned char*` спецификация разрешает в особом порядке указывать на всё что угодно. Это значит, что они могут указывать на любую область памяти.

* Только для C++, типы базовых классов, возможно, с *CV* (`const` и/или `volatile`) квалификаторами, могут перекывыться дочерними типами. (Например: если класс `dog` является наследником класса `animal`, указатели и ссылки на класс `dog` и класс `animal` могут перекрываться.)

Конечно, ссылки обладают всеми теми же свойствами, что и указатели, и ссылки и указатели могут перекрываться. Для любого lvalue следует предполагать возможность перекрытия с другим lvalue, если правила говорят, что они могут перекрываться. Правила перекрытия для ссылок на значения действуют точно также, как для указателей на значения. Кроме того, любая комбинация указателей и ссылок может перекрываться, и Вам следует опираться на правила перекрытия чтобы понимать что может произойти.

## Часть вторая. Как сделать что-то, что не нравится компилятору.

Следующая программа меняет местами две половинки 32-х битного `integer`, и представляет пример типичного кода для обмена информацией, между little-endian и big-endian машинами. Он также выдаёт 6 предупреждений о нарушении правил перекрытия объектов в памяти. Многие пропустят их. Кооректный вывод программы:

	00000020 00200000

но при включённой оптимизации он становится:

	00000020 00000020

Это ТО, что предупреждение поталось сказать Вам, что оптимизатор собирается сделать вещи, которые Вам не понравятся. Не думайте что это означает, что оптимизатор испортил Ваш код. Он уже испорчен. Оптимизатор просто указал Вам на это.

## Неправильная версия:

	uint32_t
	swaphalves(uint32_t a)
	{
		uint32_t acopy=a;
		uint16_t *ptr=(uint16_t*)&acopy;	// нельзя использовать static_cast<>, неправильно.
											// Вам должно выводиться предупреждение об этом.
		uint16_t tmp=ptr[0];
		ptr[0]=ptr[1];
		ptr[1]=tmp;
		return acopy;
	}

	int main()
	{
		uint32_t a;
		a=32;
		cout << hex << setfill('0') << setw(8) << a << endl;
		a=swaphalves(a);
		cout << setw(8) << a << endl;
	}

Итак, что же здесь неправильно? Хотя `uint16_t` и `uint32_t` по правилам не могут перекрываться, это игнорируется при работе с `acopy`. Видно, что внутри `swaphalvesfunction` ничего не происходит с переменной `acopy`, функция просто возвращает начальное значение `a`. Вот аннотированный x86 ассемблер, генерируемый gcc 4.4.1 для `swaphalvesfunction`, давайте посмотрим что полшло не так;

	_Z10swaphalvesj:
		pushl %ebp
		movl %esp, %ebp
		subl $16, %esp
		movl 8(%ebp), %eax 		# get a in %eax
		movl %eax, -8(%ebp) 	# and store it in acopy
		leal -8(%ebp), %eax 	# now get eax pointing at acopy (ptr=&acopy)
		movl %eax, -12(%ebp) 	# save that ptr at -12(%ebp)
		movl -12(%ebp), %eax 	# get the ptr back in %eax
		movzwl (%eax), %eax 	# get 16 bits from ptr[0] in eax
		movw %ax, -2(%ebp) 		# store the 16 bits into tmp
		movl -12(%ebp), %eax 	# get the ptr back in eax
		addl $2, %eax 			# bump up by two to get to ptr[1]
		movzwl (%eax), %edx 	# get that 16 bits into %edx
		movl -12(%ebp), %eax 	# get ptr into eax
		movw %dx, (%eax) 		# store the 16 bits into ptr[1]
		movl -12(%ebp), %eax 	# get the ptr again
		leal 2(%eax), %edx 		# get the address of ptr[1] into edx
		movzwl -2(%ebp), %eax 	# get tmp into eax
		movw %ax, (%edx) 		# store into ptr[1]
		movl -8(%ebp), %eax 	# forget all that, return original a.
		leave
		ret

Жутковато, не правда ли? Конечно, если Вы используете gcc, вы могли бы использовать `-fno-strict-aliasing` чтобы получить то что ожидаем, но сгенерированный код не будет так хорош и Вы просто избавитесь от симптома вместо решения проблемы. Лучший способ добиться того же без получения предупреждений или некорректного вывода - это определить `swaphalves` следующим образом. Заметьте, что это поддерживается в стандартах C99 и новее, в сноске к *6.5.2.3 Structure and union members*:

>85. Если член использовавшийся для доступа к содержимому объекта `union` не является таким же как последний член, использовавшийся для записи значения в объект, соответствующая часть представления объекта начинает интерпретироваться как новый тип, что описано в 6.2.6 (процесс иногда называется "приведение типов" (type-punning)) Это может быть обманным представлением.

но Ваша польза в C++ может различаться. Все C++ компиляторы, о которых мне известно, поддерживают это, но спецификация C++ этого не разрешает, так что опасно рассчитывать на это. Сразу после этого обсуждения я предложу другое возможное (а может быть и нет) решение с использованием `memcpy`, немного менее эффективное, и поддерживаемое как C так и C++:

## Версия с `union`. Работает для C но нет гарантий портируемости в C++.

	uint32_t
	swaphalves(uint32_t a)
	{
		typedef union
		{
			uint32_t as32bit;
			uint16_t as16bit[2];
		} swapem;

		swapem s={a};
		uint16_t tmp;
		tmp=s.as16bit[0];
		s.as16bit[0]=s.as16bit[1];
		s.as16bit[1]=tmp;
		return s.as32bit;
	}
Компилятор C++  знает, что члены `union` занимают одну память, и это помогает компилятору генерировать ГОРАЗДО лучший код:

	_Z10swaphalvesj:
		pushl %ebp 			# save the original value of ebp
		movl %esp, %ebp 	# point ebp at the stack frame
		movl 8(%ebp), %eax 	# get a in eax
		popl %ebp 			# get the original ebp value back
		roll $16, %eax 		# swap the two halves of a and return it
		ret

Этак, сделайте это неправильно через странные приведения и получите некорректный код, или через выключение `strict-aliasing` получите неэффективный код, или сделайте это правильно и получите эффективный.

Вы можете также сделать ту же вещь, используя `memcpy` с `char *` чтобы данные поменять местами данные, и это скорей всего будет эффективно. Постойте, спросите Вы меня, как такое может быть? Будет как минимум два вызова функции `memcpy`, добавленные в код! Что ж, gcc и другие современные компиляторы имеют умные оптимизаторы и во многих случаях, (включая этот) уберут `call` для `memcpy`. Это сделает метод более портабельным и таким же эффективным как остальные. Вот как это будет выглядеть:

## Версия с `memcpy`, совместимая со стандартами C и C++ и в тоже время эффективная

	uint32_t
	swaphalves(uint32_t a)
	{
		uint16_t as16bit[2],tmp;
		memcpy(as16bit, &a, sizeof(a));
		tmp = as16bit[0];
		as16bit[0] = as16bit[1];
		as16bit[1] = tmp;
		memcpy(&a, as16bit, sizeof(a));
		return a;
	}

Для вышеприведённого кода, компилятор C сгенерирует код код, близкий к предыдущему решению, но с дополнительными двумя вызовами `memcpy` (возможно соптимизированными). gcc генерирует код идентичный предыдущему решению. Вы можете придумать другие варианты, которые заменят чтение и запись через указатель на `char` локально вместо вызовов `memcpy`.

Подобные приёмы используются в коде, работающем с сетью, где Вы не можете знать какого типа пакет Вам пришёл пока не проверите его. `unions` и/или `memcpy` Ваши друзья и в этом случае.

## Ключевое слово `restrict`

В C99, но не во всех C++ при помощи ключевого слова `restrict` Вы можете пообещать компилятору, что указатель на что-то не перекрывается. В ситуации когда компилятор должен ожидать что вещи могут перекрываться, Вы можете сказать компилятору, что обещаете, что этого не будет. Как здесь:

	void foo(int * restrict i1, int * restrict i2);

Вы говорите, что обещаете компилятору, что `i1` и `i2` никогда не укажут на один участок памяти. Вы должны хорошо знать реализацию `foo` и использовать только код который держит данное обещание, что вещи, проходящие через `i1` и `i2` никогда не перекрываются. Компилятор верит Вам и может лучше выполнить работу по оптимизации. Если Вы нарушаете обещание, ваша полезность может изменяться (и помимо этого я подразумеваю, Вам почти наверное захочется плакать). Это не допустимо для C++.

Если у Вас есть комментарии, правки, предложения по улучшению или примеры - не стесняйтесь, пишите мне.

Спасибо,
Патрик Хоган (Patrick Horgan)
patrick at dbp-consulting dot com


## Комплименты и благодарности

Особая благодарность отправляется к людям, участвовашим в обсуждении этого документа в рассылках boost-users и gcc-help. В особенности я хотел бы поблагодарить Вацлава Хайсмана (Václav Haisman), Томаса Хеллера (Thomas Heller) которые писали версию с `memcpy`, размещённую здесь и выяснили, что она генерирует точно такой же ассемблер, и Андрю Хали (Andrew Haley), который выяснил, что наиболее портабельный способ через определение `union` и такде выяснил, что gcc избавится от вызова `memcpy`

Дополнительно я хотел бы поблагодарить Геба Джонса (Gabe Jones) за отлов тараканов в голове :)