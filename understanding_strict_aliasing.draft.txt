Осмысление правил перекрытия объектов в памяти в языках C/C++
или - Почему этот #$@##@^% компилятор не даёт мне делать то что нужно!
автор Патрик Хоган (Patrick Horgan)

Итак, в чём проблема?

Существует множество заблуждений о правилах перекрытия объектов в памяти. Главный источник заблуждений в том,
что существует две разных аудитории, говорящих о strict aliasing (*) - разработчики, использующие компиляторы
и авторы компиляторов. В этой статье я собираюсь попробовать разлжить всё по полочкам для вас. Вещи, о которых
я собираюсь рассказать основаны на правилах перекрытия в C89/90 (6.3), C98/99 (6.5/7) а также в C++98 (3.10/15),
и C++0x (3.10/10). Для того, чтобы найти правила aliasing'а в любой текущей версии C или C++ стандарта, ищите
по словам <<may not be aliased>>, которые Вы найдёте в сноске, на которую ссылается секция, описывающая допустимые
формы перекрытия. Для справки о том, что имели ввиду создатели спецификаций, см. C89 Rationale Section 3.3 Expressions,
где они рассказывают почему и как были выведены правила перекрытия.

Разработчики начинают интересоваться aliasing'ом когда компилятор выдаёт им предупреждение о приведении типов и
правилах перекрытия объектов в памяти, и они пытаются понять что же значат эти предупреждения. Они гуглят эти сообщения,
они находят ссылки к секции aliasing'а в одной из C или C++ спецификаций и думают: <<Да, это то что я пытаюсь сделать,
перекрытие>>. Потом они изучают секцию соответствующей спецификации так, будто они учат магические руны и пытаются
угадать правила, которые позволят делать им вещи, которые они пытаются сделать. Они думают, что правила перекрытия
написаны чтобы объяснить им как следует делать приведение типов. Нельзя быть более далёким от истины.

Создатели компиляторов знают для чего нужны правила strict aliasing. Они написаны чтобы позволить создателям компилятора
знать, когда они могут безопасно полагать, что изменение, сделанное для одной переменной не повлияет на значение другой
переменной и наоборот, конда им следует предполанать, что две переменные могут по факту указывать на один и тот же
участок памяти.

Итак, эта статья разделена на две части. Во-первых я рассказу что такое strict aliasing и почему он существует, а затем
я расскажу как делать вещи, необходимые разработчикам способами, не приводящими к конфликтам с этими правилами.

(*) Примечание: в gcc термин `strict aliasing' переводится как <<правила перекрытия объектов в памяти>>.
Т.к. это довольно длинная формулировка, в статье иногда будет использоваться оригинальный термин.
