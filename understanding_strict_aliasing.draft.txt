Осмысление правил перекрытия объектов в памяти в языках C/C++
или - Почему этот #$@##@^% компилятор не даёт мне делать то что нужно!
автор Патрик Хоган (Patrick Horgan)

Итак, в чём проблема?

Существует множество заблуждений о правилах перекрытия объектов в памяти. Главный источник заблуждений в том,
что существует две разных аудитории, говорящих о strict aliasing (*) - разработчики, использующие компиляторы
и авторы компиляторов. В этой статье я собираюсь попробовать разлжить всё по полочкам для вас. Вещи, о которых
я собираюсь рассказать основаны на правилах перекрытия в C89/90 (6.3), C98/99 (6.5/7) а также в C++98 (3.10/15),
и C++0x (3.10/10). Для того, чтобы найти правила aliasing'а в любой текущей версии C или C++ стандарта, ищите
по словам <<may not be aliased>>, которые Вы найдёте в сноске, на которую ссылается секция, описывающая допустимые
формы перекрытия. Для справки о том, что имели ввиду создатели спецификаций, см. C89 Rationale Section 3.3 Expressions,
где они рассказывают почему и как были выведены правила перекрытия.

Разработчики начинают интересоваться aliasing'ом когда компилятор выдаёт им предупреждение о приведении типов и
правилах перекрытия объектов в памяти, и они пытаются понять что же значат эти предупреждения. Они гуглят эти сообщения,
они находят ссылки к секции aliasing'а в одной из C или C++ спецификаций и думают: <<Да, это то что я пытаюсь сделать,
перекрытие>>. Потом они изучают секцию соответствующей спецификации так, будто они учат магические руны и пытаются
угадать правила, которые позволят делать им вещи, которые они пытаются сделать. Они думают, что правила перекрытия
написаны чтобы объяснить им как следует делать приведение типов. Нельзя быть более далёким от истины.

Создатели компиляторов знают для чего нужны правила strict aliasing. Они написаны чтобы позволить создателям компилятора
знать, когда они могут безопасно полагать, что изменение, сделанное для одной переменной не повлияет на значение другой
переменной и наоборот, конда им следует предполанать, что две переменные могут по факту указывать на один и тот же
участок памяти.

Итак, эта статья разделена на две части. Во-первых я рассказу что такое strict aliasing и почему он существует, а затем
я расскажу как делать вещи, необходимые разработчикам способами, не приводящими к конфликтам с этими правилами.

Часть первая. Что именно есть перекрытие?

Перекрытие (aliasing) иэто когда одно или более lvalue указывает на тотже участок памяти (когда Вы слышите <<lvalue>>,
думайте о вещах (переменные), которые могут быть на левой стороне присваиваний)

Как пример:
int anint;
int *intptr =&anint;

Если Вы меняет значение *intptr, значение, на которое указывает anint тоже меняется, потому что *intptr перекрывает
(aliases) anint. Это просто другое имя тойже вещи.
Другой пример:
int anint;
void foo(int &i1, int &i2);
foo(anint,anint);

Внутри тела функции, после того как мы использовали anint в качестве обоих аргументов, есть две ссылки, i1 и i2 alias'а
т.е. ссылки на одну область памяти когда функция вызывается таким образом.

В чём проблема?

Проверим следующий код:
int anint;
void foo(double *dblptr)
{
  anint=1;
  *dblptr=3.14159;
  bar(anint);
}

Если посмотреть на пример, кажется безопасным предполагать что аргумент bar() - константа, равная 1. В старые добрые
деньки создатели компиляторов должны были исходить из худшего предположения о перекрывающем присваивании чтобы
поддердивать огромное количество унаследованного кода с дикого запада. Они не могли сказать что было бы безопасно
предполагать что аргумент bar был 1. Они должны были вставлять код для повторной выгрузки значения anint для вызова
функции потому что промежуточное присваивание через dblptr могло изменить значение anint, если бы dblptr указывал на
неё. Возможно, что вызов выглядел как foo((double *) &anint).

Именно эту проблему призван решить strict aliasing. Перед создателями оптимизирующих компиляторов был низко весящий
фрукт, и они хотели заставить программистов следовать правилам перекрытия объектов в памяти чтобы его сорвать.
Перекрытие и проблемы к которым оно приводит существуют столько, сколько существует язык C.

The difference lately, is that compiler writers are being strict about the rules and enforcing them when optimization is in effect. In their respective standards, C and C++ include lists of the things that can legitimately alias, (see the next section), and in all other cases, compiler writers are allowed to assume no interactions between lvalues. Anything not on the list can be assumed to not alias, and compiler writers are free to do optimizations that make that assumption. For anything on the list, aliasing could possibly occur and compiler writers have to assume that it does. When compiler writers follow these lists, and assume that your code follows the rules, it's called strict-aliasing. Under strict aliasing, the compiler writer is free to optimize the function foo above because incompatible types,double and int, can't alias. That means that if you do call foo as foo((double *)&anint) something will go quickly wrong, but you get what you deserve.



(*) Примечание: в gcc термин `strict aliasing' переводится как <<правила перекрытия объектов в памяти>>.
Т.к. это довольно длинная формулировка, в статье иногда будет использоваться оригинальный термин.
